from .base import Task, Global
from .path import (
    path_to_actions,
    estimate_energy_cost,
    find_path_in_dynamic_environment,
)


class VoidSinger(Task):

    def __repr__(self):
        return f"{self.__class__.__name__}{self.target.coordinates}"

    def completed(self, state, ship):
        if not ship.can_move() and ship.node != self.target:
            return True
        return False

    @classmethod
    def generate_tasks(cls, state):
        reward_nodes = set(state.space.reward_nodes)

        for ship in state.fleet:
            if isinstance(ship.task, VoidSinger):
                target = ship.task.target
                if target in reward_nodes:
                    reward_nodes.remove(target)

        tasks = []
        for reward_node in reward_nodes:
            tasks.append(cls(reward_node))
        return tasks

    def evaluate(self, state, ship):
        if not ship.can_move():
            if ship.node == self.target:
                return 1000
            else:
                return 0

        rs = state.get_resumable_dijkstra(ship.unit_id)
        path = rs.find_path(self.target.coordinates)
        if not path:
            return 0
        energy_needed = estimate_energy_cost(state.space, path)

        p = Global.Params
        score = (
            p.VOID_SINGER_INIT_SCORE
            + p.VOID_SINGER_PATH_LENGTH_MULTIPLIER * len(path)
            + p.VOID_SINGER_ENERGY_COST_MULTIPLIER * energy_needed
            + p.VOID_SINGER_NODE_ENERGY_MULTIPLIER * self.target.energy_gain
        )

        return score

    def apply(self, state, ship):
        path = find_path_in_dynamic_environment(
            state,
            start=ship.coordinates,
            goal=self.target.coordinates,
            ship_energy=ship.energy,
        )

        ship.action_queue = path_to_actions(path)
