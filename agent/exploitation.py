from .base import Task
from .path import (
    path_to_actions,
    estimate_energy_cost,
    find_path_in_dynamic_environment,
)


class VoidSinger(Task):

    def __repr__(self):
        return f"{self.__class__.__name__}{self.target.coordinates}"

    def completed(self, state):
        return False

    @classmethod
    def generate_tasks(cls, state):
        reward_nodes = set(state.space.reward_nodes)

        for ship in state.fleet:
            if isinstance(ship.task, VoidSinger):
                target = ship.task.target
                if target in reward_nodes:
                    reward_nodes.remove(target)

        tasks = []
        for reward_node in reward_nodes:
            tasks.append(cls(reward_node))
        return tasks

    def evaluate(self, state, ship):
        if not ship.can_move():
            if ship.node == self.target:
                return 1000
            else:
                return 0

        rs = state.get_resumable_dijkstra(ship.unit_id)
        path = rs.find_path(self.target.coordinates)
        energy_needed = estimate_energy_cost(state.space, path)
        grid_distance = rs.distance(self.target.coordinates)

        energy_remain = ship.energy - energy_needed

        score = 800 - grid_distance + energy_remain

        return score

    def apply(self, state, ship):
        path = find_path_in_dynamic_environment(
            state,
            start=ship.coordinates,
            goal=self.target.coordinates,
            ship_energy=ship.energy,
        )

        ship.action_queue = path_to_actions(path)
